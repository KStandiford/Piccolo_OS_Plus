<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Piccolo OS Plus: Piccolo OS</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Piccolo OS Plus<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">A feature rich extension of Piccolo OS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div><div class="header">
  <div class="headertitle"><div class="title">Piccolo OS </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_C__Users_Keith_source_repos_piccolo_os_plus_docs_piccolo_1_1"></a>Piccolo OS is a small multitasking OS for the Raspberry Pi Pico. It is designed primarily as a teaching tool. It demonstrates the fundamentals of a co-operative multitasking OS and the Arm Cortex-M0+.</p>
<h1><a class="anchor" id="autotoc_md44"></a>
Limitations</h1>
<p >Many! Including lack of per-task memory, multicore support, mutexes, queues, a file system, networking, a shell, and so on...</p>
<h1><a class="anchor" id="autotoc_md45"></a>
A Comma A Day Keeps The Pedants Away</h1>
<p >Since the Internet seems to be full of people with way too much time on their hands, I would just like to kindly shoo away any C/C++ pedants out there. Yes, I am sure there are a million different ways to achieve many of the same results. Yes, I am sure there are some fine points of language semantics that could be argued about. Yes, I am sure you have a more efficient way of writing some of the functions.</p>
<p >To be honest, I am not interested.</p>
<p >Having said that, like-minded people who wish to contribute and extend Piccolo OS are welcome. See <b>Contributing</b></p>
<h1><a class="anchor" id="autotoc_md46"></a>
Build Instructions</h1>
<p >Make sure you have the Pico C/C++ SDK installed and working on your machine. <a href="https://datasheets.raspberrypi.org/pico/getting-started-with-pico.pdf">Getting started with Raspberry Pi Pico is the best place to start.</a></p>
<p >You need to have PICO_SDK_PATH defined, e.g. <code>export PICO_SDK_PATH=/home/pi/pico/pico-sdk/</code></p>
<p >Clone the code from the repository. Change directory into <code>build</code> and run <code>cmake -DCMAKE_BUILD_TYPE=Debug ..</code> (for a debug build) or <code>cmake ..</code> (for a release build).</p>
<p >Run <code>make</code></p>
<p >The resulting file <code>piccolo_os_demo.elf</code> can be flashed on your Pico in the normal way.</p>
<h1><a class="anchor" id="autotoc_md47"></a>
Design</h1>
<p >First to define some terminology. The <em>kernel</em> is the <code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code> function (and later <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a></code> which is called by <code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code> and never returns.) The job of the kernel is to allow for tasks to be created and then, in a round-robin fashion, pick the next task that needs to be run, save the kernel stack, restore the task's stack and jump to the program counter (PC) last used by the user task.</p>
<p >A <em>task</em> (i.e. <em>user task</em>) is a function that is run by Piccolo in a round-robin fashion along with the other <em>tasks</em>. For example, a function that flashes the onboard LED. Each <em>task</em> has its own stack, separate from the main stack (which is used by the kernel).</p>
<p >So, there are two types of stack, the Main Stack Pointer (MSP) and Process Stack Pointer (PSP). The Process Stack Pointer (PSP) is used by the current task, and the MSP is used by OS Kernel and exception handlers.</p>
<p >To switch from the kernel to a task, Piccolo needs to save the kernel state on the main stack, restore the user state from the process stack, and jump to the task PC that was saved. To switch from a task to the kernel, the opposite happens, in that the user stack is saved, the kernel stack is restored. The task to kernel switch happens via an interrupt, a SVC.</p>
<p >Piccolo OS uses a set of stacks, one for each task. The stacks are defined in <code><a class="el" href="group___intern.html#structpiccolo__os__internals__t" title="Piccolo OS internal data structure.">piccolo_os_internals_t</a></code> along with the number of created tasks, plus the index to the current task.</p>
<h2><a class="anchor" id="autotoc_md48"></a>
piccolo_init()</h2>
<p ><code><a class="el" href="group___intern.html#gadff28f28fb63a151704985aba1116319" title="Initialize the piccolo run time environment.">piccolo_init()</a></code> initializes the number of created tasks to zero, then calls the standard Pico SDK initialization function <code>stdio_init_all()</code>. After reset, the processor is in thread (privileged) mode. <a class="el" href="piccolo__os_8c.html#ad26714ff2af550677e812c46aff4450f">__piccolo_task_init_stack()</a> switches to handler mode to ensure an appropriate exception return.</p>
<p >Once <code><a class="el" href="group___intern.html#gadff28f28fb63a151704985aba1116319" title="Initialize the piccolo run time environment.">piccolo_init()</a></code> has been called the rest of <code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code>, and any other functions like <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a></code> will be run in handler mode. This can cause problems with the Pico C/C++ SDK, especially with the timers as they are hardware/interrupt based.</p>
<h2><a class="anchor" id="autotoc_md49"></a>
piccolo_create_task()</h2>
<p >To create a task the initial stack frame is created. It needs to mimic what would be saved by hardware and by the software. Once the stack is initialized, <code><a class="el" href="piccolo__os_8c.html#a2f8a0464da18ff39639b817e46da1deb">__piccolo_pre_switch()</a></code> is called to simulate a return from the exception state. The stack is then ready to be used for context switching.</p>
<h2><a class="anchor" id="autotoc_md50"></a>
piccolo_start()</h2>
<p >This is an infinite loop that picks the next stack (i.e. next task) to use in a round-robin fashion. When <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> or <code><a class="el" href="group___cinter.html#ga1f7412fd294106bc331d14c335d72b14" title="Same as piccolo_yield.">piccolo_syscall()</a></code> is called an exception is raised (a SVC exception), which causes the interrupt handler <code>isr_svcall</code> to be called.</p>
<h2><a class="anchor" id="autotoc_md51"></a>
piccolo_yield() / piccolo_syscall()</h2>
<p >This function is very simple:</p>
<div class="fragment"><div class="line">nop</div>
<div class="line">svc 0</div>
<div class="line">nop</div>
<div class="line">bx lr</div>
</div><!-- fragment --><p >The SVC instruction causes an exception which is handled by <code>isr_svcall</code>.</p>
<h2><a class="anchor" id="autotoc_md52"></a>
isr_svcall()</h2>
<p >This is invoked via the SVC exception. It saves the current user task onto the PSP and then restores the kernel stack. It then returns to the last PC used by the kernel before it was switched out. Control returns to the kernel (<code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code> or <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a></code>).</p>
<h2><a class="anchor" id="autotoc_md53"></a>
__piccolo_pre_switch()</h2>
<p ><code><a class="el" href="piccolo__os_8c.html#a2f8a0464da18ff39639b817e46da1deb">__piccolo_pre_switch()</a></code> saves the kernel state, i.e. R4 to R12 (which contains the PSR) and the LR (the return address), onto the main stack. Then, the task state (the register R4 to R11 and the LR) are restored from the task's PSP stack. This is in R0, which is used to set the PSP register. The code then jumps to the LR (restored from the PSP).</p>
<p >If the LR is THREAD_PSP (i.e. 0xFFFFFFFD, a special return address recognized by the CPU) then THREAD_PSP forces a return to Thread mode, execution continues using the PSP.</p>
<h2><a class="anchor" id="autotoc_md54"></a>
piccolo_sleep()</h2>
<p >Since Piccolo OS isn't preemptive, then using the Pico's C/C++ sleep functions will cause execution to block. <code><a class="el" href="group___intern.html#ga1349857a1febc3090dbc9c2773a22bd2" title="sleeps for a specified number of milliseconds">piccolo_sleep()</a></code> is a replacement function that calls <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> while waiting for the specified amount of time to pass.</p>
<h1><a class="anchor" id="autotoc_md55"></a>
Thread mode and Handler mode in the Cortex-M0+</h1>
<p >When the Cortex-M0+ processor is running a program it can be either in Thread mode or Handler mode. Thread mode and Handler mode are almost completely the same. The only difference is that Thread mode uses (if desired) the Process Stack Pointer (PSP) rather than the Main Stack Pointer (MSP).</p>
<p >After reset, the processor is in Thread mode.</p>
<h1><a class="anchor" id="autotoc_md56"></a>
Context Switching</h1>
<p >The Cortex-M0 and Cortex-M0+ processors (also applicable to Cortex-M3/M4/M7) have two Stack Pointers (SPs). There are two types of stack, the Main Stack Pointer (MSP) and Process Stack Pointer (PSP). The Process Stack Pointer (PSP) is used by the current task, and the MSP is used by OS Kernel and exception handlers. The stack pointer selection is determined by the CONTROL register, a special registers. When a context switch occurs the status is saved on the stack.</p>
<h2><a class="anchor" id="autotoc_md57"></a>
Overview</h2>
<ol type="1">
<li>Piccolo OS -&gt; save kernel state on MSP -&gt;</li>
<li>restore TASK1 state from PSP_1 -&gt; TASK1 -&gt; save TASK1 state to PSP_1 -&gt;</li>
<li>restore kernel state from MSP -&gt; Piccolo OS -&gt; save kernel on MSP -&gt;</li>
<li>restore TASK2 state from PSP_2 -&gt; TASK2 -&gt; save TASK2 state to PSP_2 -&gt;</li>
<li>restore kernel state from MSP -&gt; Piccolo OS -&gt; save kernel on MSP -&gt;</li>
<li>restore TASK3 state from PSP_3 -&gt; TASK3 -&gt; save TASK3 state to PSP_3 -&gt;</li>
<li>restore kernel state from MSP -&gt; Go to step 1.</li>
</ol>
<h2><a class="anchor" id="autotoc_md58"></a>
Process Stack Pointer</h2>
<div class="fragment"><div class="line">        Exception frame saved by the hardware onto stack:</div>
<div class="line">        +------+</div>
<div class="line">        | xPSR | 0x01000000 i.e. PSR Thumb bit</div>
<div class="line">        |  PC  | Pointer to task function</div>
<div class="line">        |  LR  | </div>
<div class="line">        |  R12 | </div>
<div class="line">        |  R3  | </div>
<div class="line">        |  R2  | </div>
<div class="line">        |  R1  | </div>
<div class="line">        |  R0  | </div>
<div class="line">        +------+</div>
<div class="line">        Registers saved by the software (isr_svcall):</div>
<div class="line">        +------+</div>
<div class="line">        |  LR  | THREAD_PSP i.e. 0xFFFFFFFD</div>
<div class="line">        |  R7  | </div>
<div class="line">        |  R6  | </div>
<div class="line">        |  R5  | </div>
<div class="line">        |  R4  | </div>
<div class="line">        |  R11 | </div>
<div class="line">        |  R10 | </div>
<div class="line">        |  R9  | </div>
<div class="line">        |  R8  | </div>
<div class="line">        +------+</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md59"></a>
Main Stack Pointer</h2>
<div class="fragment"><div class="line">        Registers saved by the software (__piccolo_pre_switch):</div>
<div class="line">        +------+</div>
<div class="line">        |  LR  |</div>
<div class="line">        |  R7  |</div>
<div class="line">        |  R6  |</div>
<div class="line">        |  R5  |</div>
<div class="line">        |  R4  |</div>
<div class="line">        |  R12 | NB: R12  (i.e IP) is included, unlike user state</div>
<div class="line">        |  R11 |</div>
<div class="line">        |  R10 |</div>
<div class="line">        |  R9  |</div>
<div class="line">        |  R8  | </div>
<div class="line">        +------+</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md60"></a>
R0 to R3</h2>
<p >When the CPU is interrupted, the hardware will store R0 to R3, the PC etc., onto the stack. It is automatic. The interrupt handler <code>isr_svcall()</code> needs to save <b>all</b> the registers (the whole context) so it saves R4 to R11, etc. This means all the registered are saved. However, you may have noticed that when there is a switch from the <em>kernel</em> to a <em>task</em> via <code><a class="el" href="piccolo__os_8c.html#a2f8a0464da18ff39639b817e46da1deb">__piccolo_pre_switch()</a></code> then this is software only (no SVC instruction, no interrupt) and so the kernel's R0 to R3 are not saved on the main stack. The reason is that the calling ARM calling convention (when you call a function) states that R0 to R3 are scratch registers and you can't rely on their contents after a branch to another bit of code. So R0 to R3 don't need to be saved as the C compiler knows not to rely on the value of those registers after a function call, and invoking <code><a class="el" href="piccolo__os_8c.html#a2f8a0464da18ff39639b817e46da1deb">__piccolo_pre_switch()</a></code> is a function call!</p>
<h1><a class="anchor" id="autotoc_md61"></a>
Typical sequence of events</h1>
<p >Let say you have two tasks, <em>task1</em> and <em>task2</em>. All they do is yield control back to the kernel. Like this:</p>
<div class="fragment"><div class="line">void task1(void) {</div>
<div class="line">  while (true) {</div>
<div class="line">    piccolo_yield();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p >Below, {T} means Thread mode, {H} means Handler mode, {HI} means Handler mode, but in actual Interrupt handler.</p>
<p >Remember that, the <em>kernel</em> is the <code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code> function and later <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a></code> (which is called by <code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code> and never returns).</p>
<p >The typical sequence of events, from start-up, is:</p>
<ol type="1">
<li>{T} The processor starts in Thread mode</li>
<li>{T} <code><a class="el" href="group___intern.html#gadff28f28fb63a151704985aba1116319" title="Initialize the piccolo run time environment.">piccolo_init()</a></code> which calls <code><a class="el" href="group___intern.html#ga5518a5e6b68942455ca2d544f2941209" title="Switch the scheduler to handler mode.">__piccolo_task_init()</a></code><ul>
<li><code><a class="el" href="group___intern.html#ga5518a5e6b68942455ca2d544f2941209" title="Switch the scheduler to handler mode.">__piccolo_task_init()</a></code> creates a dummy stack and calls <code><a class="el" href="piccolo__os_8c.html#ad26714ff2af550677e812c46aff4450f">__piccolo_task_init_stack()</a></code></li>
<li><code><a class="el" href="piccolo__os_8c.html#ad26714ff2af550677e812c46aff4450f">__piccolo_task_init_stack()</a></code> saves the kernel state, i.e. R4 to R12 (which contains the PSR) and the LR (the return address), onto the main stack.</li>
<li>It then switches to the PSP (which is, in fact, a dummy stack) and triggers an interrupt</li>
</ul>
</li>
<li>{HI} <code>isr_svcall()</code> handles the interrupt. It saves the current task state (R4 to R11 and the LR) onto the PSP (the dummy stack).<ul>
<li>{HI} It then restores the kernel state from the main stack and returns to the kernel using the LR saved on the main stack in 2.</li>
</ul>
</li>
<li>{H} After the interrupt, processing continues in <code><a class="el" href="group___intern.html#ga5518a5e6b68942455ca2d544f2941209" title="Switch the scheduler to handler mode.">__piccolo_task_init()</a></code> and eventually <code><a class="el" href="group___intern.html#gadff28f28fb63a151704985aba1116319" title="Initialize the piccolo run time environment.">piccolo_init()</a></code> but now in Handler mode.</li>
<li>{H} Next <em>task1</em> is created via <code>piccolo_create_task(&amp;task1);</code></li>
<li>{H} In <code><a class="el" href="group___intern.html#ga71a59d00d48e0512b849615509ef1c4b" title="Initialize user task stack for execution.">__piccolo_os_create_task()</a></code> a new stack is initialized for the task, including the frames saved by the hardware when an interrupt is called (see Context Switching above).</li>
<li>{H} Once the stack has been set up, <code><a class="el" href="piccolo__os_8c.html#a2f8a0464da18ff39639b817e46da1deb">__piccolo_pre_switch()</a></code> is called passing the stack as a parameter.</li>
<li>{H} <code><a class="el" href="piccolo__os_8c.html#a2f8a0464da18ff39639b817e46da1deb">__piccolo_pre_switch()</a></code> saves the kernel state, i.e. R4 to R12 (which contains the PSR) and the LR (the return address), onto the main stack.</li>
<li>{H} The task state (the register R4 to R11 and the LR) are restored from the stack passed in at step 7. This is in R0.</li>
<li>{H} R0 is set as the PSP and a jump is made to the LR, which is actually THREAD_PSP (i.e. 0xFFFFFFFD, a special return address recognized by the CPU)</li>
<li>{T} THREAD_PSP forces a return to Thread mode, execution continues using the PSP. The PSP has the address of <em>task1</em>, as set up in step 6. See <code>stack[15] = (unsigned int)start;</code> in <code><a class="el" href="group___intern.html#ga71a59d00d48e0512b849615509ef1c4b" title="Initialize user task stack for execution.">__piccolo_os_create_task()</a></code></li>
<li>{T} <em>task1</em> is just a loop that calls <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code></li>
<li>{T} <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> intentionally calls SVC and forces an interrupt that will be handled by <code>isr_svcall()</code></li>
<li>{HI} <code>isr_svcall()</code> handles the interrupt. It saves the state of <em>tasks1</em> task (R4 to R11 and the LR) onto the PSP belonging <em>task1</em> (see steps 10. and 11.).<ul>
<li>{HI} It then restores the kernel state from the main stack and returns to the kernel using the LR saved on the main stack in 8.</li>
</ul>
</li>
<li>{H} After the interrupt, processing continues in <code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code></li>
<li>{H} Next <em>task2</em> is created via <code>piccolo_create_task(&amp;task2);</code></li>
<li>Steps 6. to 15. are repeated, but now for <em>task2</em></li>
<li>{H} After the interrupt, processing continues in <code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code>. Now that our tasks are created and running, we call <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a>;</code></li>
<li>{H} Using a simple round-robin algorithm, <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a>;</code> just picks the next task and calls <code><a class="el" href="piccolo__os_8c.html#a2f8a0464da18ff39639b817e46da1deb">__piccolo_pre_switch()</a></code> passing the tasks stack as a parameter.<ul>
<li>{H} <code><a class="el" href="piccolo__os_8c.html#a2f8a0464da18ff39639b817e46da1deb">__piccolo_pre_switch()</a></code> saves the kernel state, i.e. R4 to R12 (which contains the PSR) and the LR (the return address), onto the main stack.</li>
<li>{H} The task state (the register R4 to R11 and the LR) are restored from the stack passed as the parameter to <code><a class="el" href="piccolo__os_8c.html#a2f8a0464da18ff39639b817e46da1deb">__piccolo_pre_switch()</a></code>. This is in R0.</li>
<li>{H} R0 is set as the PSP and a jump is made to the LR, which is actually THREAD_PSP (i.e. 0xFFFFFFFD, a special return address recognized by the CPU)</li>
<li>{T} THREAD_PSP forces a return to Thread mode, execution continues using the PSP. The PSP has the address of where to continue in the task. This address was saved into the LR (and saved onto the PSP stack) when the call to <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> was made.</li>
<li>{T} Execution continues until <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> is called again.</li>
</ul>
</li>
<li>{T} <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> intentionally calls SVC and forces an interrupt that will be handled by <code>isr_svcall()</code></li>
<li>{HI} <code>isr_svcall()</code> handles the interrupt. It saves the state of the current task (R4 to R11 and the LR) onto the PSP belonging to the task.<ul>
<li>{HI} It then restores the kernel state from the main stack and returns to the kernel using the LR saved on the main stack.</li>
</ul>
</li>
<li>{H} After the interrupt, processing continues in <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a>;</code></li>
<li>Jump to step 19.</li>
</ol>
<h2><a class="anchor" id="autotoc_md62"></a>
TL;DR</h2>
<p >Below, {T} means Thread mode, {H} means Handler mode, {HI} means Handler mode, but in actual Interrupt handler.</p>
<p >Remember that, the <em>kernel</em> is the <code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code> function and later <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a></code> (which is called by <code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code> and never returns).</p>
<ol type="1">
<li>{T} The processor starts in Thread mode, switch to Handler mode</li>
<li>{H} Create <em>task1</em><ul>
<li>{H} Initialize a stack for the task, including the frames saved by the hardware when an interrupt is called (see Context Switching above).</li>
<li>{H} <code><a class="el" href="piccolo__os_8c.html#a2f8a0464da18ff39639b817e46da1deb">__piccolo_pre_switch()</a></code> saves the kernel state, onto the main stack; and restores the task state from the process stack (PSP).</li>
<li>{T} Force a return to Thread mode, execution continues using the program counter stored in the PSP.</li>
<li>{T} Execution continues until <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> is called.</li>
</ul>
</li>
<li>{T} <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> intentionally calls SVC and forces an interrupt that will be handled by <code>isr_svcall()</code></li>
<li>{HI} <code>isr_svcall()</code> saves the state of <em>tasks1</em> onto the PSP. It then restores the kernel state from the main stack and returns to the kernel.</li>
<li>{H} Create <em>task2</em><ul>
<li>{H} Initialize a stack for the task, including the frames saved by the hardware when an interrupt is called (see Context Switching above).</li>
<li>{H} <code><a class="el" href="piccolo__os_8c.html#a2f8a0464da18ff39639b817e46da1deb">__piccolo_pre_switch()</a></code> saves the kernel state, onto the main stack; and restores the task state from the process stack (PSP).</li>
<li>{T} Force a return to Thread mode, execution continues using the program counter stored in the PSP.</li>
<li>{T} Execution continues until <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> is called.</li>
</ul>
</li>
<li>Now that our tasks are created and running, we call <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a>;</code></li>
<li>{H} Using a simple round-robin algorithm, <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a>;</code> just picks the next task and calls <code><a class="el" href="piccolo__os_8c.html#a2f8a0464da18ff39639b817e46da1deb">__piccolo_pre_switch()</a></code> passing the tasks stack as a parameter.<ul>
<li>{H} <code><a class="el" href="piccolo__os_8c.html#a2f8a0464da18ff39639b817e46da1deb">__piccolo_pre_switch()</a></code> saves the kernel state, onto the main stack.</li>
<li>{H} The task state are restored from the task's PSP</li>
<li>{T} Force a return to Thread mode, execution continues using the program counter stored in the PSP.</li>
<li>{T} Execution continues until <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> is called again.</li>
</ul>
</li>
<li>{T} <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> intentionally calls SVC and forces an interrupt that will be handled by <code>isr_svcall()</code></li>
<li>{HI} <code>isr_svcall()</code> saves the state of the task onto its PSP. It then restores the kernel state from the main stack and returns to the kernel (i.e. <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a>;</code>)</li>
<li>Go to step 7.</li>
</ol>
<h2><a class="anchor" id="autotoc_md63"></a>
Still too long</h2>
<p >Below, {T} means Thread mode, {H} means Handler mode.</p>
<p >Remember that, the <em>kernel</em> is the <code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code> function and later <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a></code> (which is called by <code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code> and never returns).</p>
<ol type="1">
<li>{T} The processor starts in Thread mode, switch to Handler mode</li>
<li>{H} Create <em>task1</em><ul>
<li>{H} Initialize a stack for it (PSP) then save the kernel state, onto the main stack; and restore the task state from the process stack (PSP).</li>
<li>{T} Force a return to Thread mode, execution continues using the program counter stored in the PSP until <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> is called.</li>
</ul>
</li>
<li>{T} <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> intentionally forces an interrupt that saves the state of <em>tasks1</em> onto the PSP and restores the kernel state from the main stack. Execution continues in the kernel.</li>
<li>{H} Create <em>task2</em><ul>
<li>{H} Initialize a stack for it (PSP) then save the kernel state, onto the main stack; and restore the task state from the process stack (PSP).</li>
<li>{T} Force a return to Thread mode, execution continues using the program counter stored in the PSP until <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> is called.</li>
</ul>
</li>
<li>{T} <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> intentionally forces an interrupt that saves the state of <em>tasks2</em> onto the PSP and restores the kernel state from the main stack. Execution continues in the kernel.</li>
<li>Now that our tasks are created and running, we call <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a></code></li>
<li><code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a></code> just picks the next task and calls <code><a class="el" href="piccolo__os_8c.html#a2f8a0464da18ff39639b817e46da1deb">__piccolo_pre_switch()</a></code> to saves the kernel state, onto the main stack; and then restored the next task from the task's PSP<ul>
<li>{T} Force a return to Thread mode, execution continues using the program counter stored in the PSP.</li>
<li>{T} Execution continues until <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> is called again.</li>
</ul>
</li>
<li><code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> forces an interrupt that saves the state of the task onto its PSP. It then restores the kernel state from the main stack and returns to the kernel (i.e. <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a>;</code>)</li>
<li>Go to step 7.</li>
</ol>
<h2><a class="anchor" id="autotoc_md64"></a>
Give me the Tom and Jerry version</h2>
<p >Remember that, the <em>kernel</em> is the <code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code> function and later <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a></code> (which is called by <code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code> and never returns).</p>
<ol type="1">
<li>Create <em>task1</em> and start running it using its own stack (PSP). It will run until <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> is called.</li>
<li>Via an interrupt <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> will saves the state of <em>tasks1</em> onto its PSP and restore the kernel state from the main stack. Execution continues in the kernel.</li>
<li>Create <em>task2</em> and start running it using its own stack (PSP). It will run until <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> is called.</li>
<li>Via an interrupt <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> will saves the state of <em>tasks2</em> onto its PSP and restore the kernel state from the main stack. Execution continues in the kernel.</li>
<li>Now that our tasks are created and running, we call <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a></code></li>
<li><code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a></code> just picks the next task, saves the kernel state, onto the main stack; and then restores the next task from the task's PSP</li>
<li>Continue executing the next task using its own stack until <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> is called.</li>
<li>Via an interrupt <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> will saves the state of the current task onto its PSP and restores the kernel state from the main stack. Execution continues in the kernel (i.e. in <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a></code>).</li>
<li>Go to 6.</li>
</ol>
<h1><a class="anchor" id="autotoc_md65"></a>
Keep track of all those stacks!</h1>
<p >Here is a brief look at some of the stacks and switches in and out of handler mode, which should help you visual what is happening with all those stacks!</p>
<h2><a class="anchor" id="autotoc_md66"></a>
piccolo_init()</h2>
<p >After call to <code><a class="el" href="group___intern.html#gadff28f28fb63a151704985aba1116319" title="Initialize the piccolo run time environment.">piccolo_init()</a>-&gt;<a class="el" href="group___intern.html#ga5518a5e6b68942455ca2d544f2941209" title="Switch the scheduler to handler mode.">__piccolo_task_init()</a>-&gt;<a class="el" href="piccolo__os_8c.html#ad26714ff2af550677e812c46aff4450f">__piccolo_task_init_stack()</a></code> </p><div class="fragment"><div class="line">Main stack (MSP)            </div>
<div class="line">+---------------+</div>
<div class="line">|  R4-R12,LR    |           Saved by __piccolo_task_init_stack(), LR is back to main()</div>
<div class="line">+---------------+</div>
</div><!-- fragment --><p> <code><a class="el" href="piccolo__os_8c.html#ad26714ff2af550677e812c46aff4450f">__piccolo_task_init_stack()</a></code> switches to using PSP0, the dummy stack from <code><a class="el" href="group___intern.html#ga5518a5e6b68942455ca2d544f2941209" title="Switch the scheduler to handler mode.">__piccolo_task_init()</a></code>, and then drops into <code><a class="el" href="group___cinter.html#ga1f7412fd294106bc331d14c335d72b14" title="Same as piccolo_yield.">piccolo_syscall()</a></code> which raises an SVC interrupt </p><div class="fragment"><div class="line">Dummy stack (PSP0)</div>
<div class="line">+---------------+           Saved by isr_svcall() using r0 which is the address of PSP0</div>
<div class="line">|  R4-R12,LR    |           LR will be 0xFFFFFFFD as this is an exception (interrupt).</div>
<div class="line">+---------------+</div>
<div class="line">|  R0-R3,LR,PC  |           Saved by hardware on PSP0</div>
<div class="line">+---------------+</div>
</div><!-- fragment --><p> The kernel, that is <code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code>, context is restored from the stack, MSP is now empty The last instruction is <code>POP {PC}</code> which pops off the LR and causes a jump back to the kernel, i.e. <code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code> </p><div class="fragment"><div class="line">Main stack (MSP)            </div>
<div class="line">+---------------+</div>
<div class="line">+---------------+</div>
</div><!-- fragment --><p> Back in <code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code> now, but the CPU is in handler mode because it has not yet returned from the exception.</p>
<p >The dummy stack is discarded and never used again.</p>
<h2><a class="anchor" id="autotoc_md67"></a>
piccolo_create_task(&amp;task1_func)</h2>
<p >Create task1: <code><a class="el" href="group___intern.html#ga7441ecb1f631f7840bb96962ca02b38d" title="Create a new task and initialize it&#39;s stack.">piccolo_create_task()</a> -&gt; <a class="el" href="group___intern.html#ga71a59d00d48e0512b849615509ef1c4b" title="Initialize user task stack for execution.">__piccolo_os_create_task()</a></code></p>
<p >Create an initial process stack PSP1 that mimics the stack from an interrupt call: </p><div class="fragment"><div class="line">Task 1 stack (PSP1)</div>
<div class="line">+---------------+           As would be saved by software, LR needs to be 0xFFFFFFFD</div>
<div class="line">|  R4-R12,LR    |                   </div>
<div class="line">+---------------+           As would be saved by hardware on PSP1</div>
<div class="line">|  R0-R3,LR,PC  |           PC is pointer task function (i.e. task1_func)</div>
<div class="line">+---------------+</div>
</div><!-- fragment --><p> Then call <code>__piccolo_pre_switch(task_stack)</code> using the newly created stack:</p>
<p ><code><a class="el" href="piccolo__os_8c.html#a2f8a0464da18ff39639b817e46da1deb">__piccolo_pre_switch()</a></code> saves the kernel state on the main stack: </p><div class="fragment"><div class="line">Main stack (MSP)            </div>
<div class="line">+---------------+           Saved by __piccolo_pre_switch(), </div>
<div class="line">|  R4-R12,LR    |           LR is back to __piccolo_os_create_task() after call to __piccolo_pre_switch()</div>
<div class="line">+---------------+</div>
</div><!-- fragment --><p> Load the state (the registers) for task1 from the stack created above. The address of that stack is in r0. Set the PSP register to R0 and then branch to LR. Since LR is 0xFFFFFFFD then this causes the CPU to end exit handler mode and return to thread mode. </p><div class="fragment"><div class="line">Task 1 stack (PSP1)</div>
<div class="line">+---------------+           As would be saved by hardware on PSP1</div>
<div class="line">|  R0-R3,LR,PC  |           PC is pointer task function (i.e. task1_func)</div>
<div class="line">+---------------+</div>
</div><!-- fragment --><p> It now restores R0 to R3 and uses the PC to carry on execution using PSP1. PC is the pointer to <code><a class="el" href="piccolo__os__demo_8c.html#a936c67e93155d8881730c729500bec25">task1_func()</a></code>.</p>
<p >PSP1 is now empty: </p><div class="fragment"><div class="line">Task 1 stack (PSP1)</div>
<div class="line">+---------------+</div>
<div class="line">+---------------+</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md68"></a>
piccolo_yield()</h2>
<p >Task 1 will run until it calls <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code>. <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> intentionally calls SVC and forces an interrupt that will be handled by <code>isr_svcall()</code> </p><div class="fragment"><div class="line">Task 1 stack (PSP1)</div>
<div class="line">+---------------+           Saved by isr_svcall() using r0 which is the address of PSP1</div>
<div class="line">|  R4-R12,LR    |           LR will be 0xFFFFFFFD as this is an exception (interrupt).</div>
<div class="line">+---------------+</div>
<div class="line">|  R0-R3,LR,PC  |           Saved by hardware on PSP1</div>
<div class="line">+---------------+</div>
</div><!-- fragment --><p> PSP1 is now ready to be used later to return to Task 1 when needed. Using a similar setup to how Task 1 was created in the first place.</p>
<p >Remember the main stack from earlier? It is still intact, as it was: </p><div class="fragment"><div class="line">Main stack (MSP)            </div>
<div class="line">+---------------+           Saved by __piccolo_pre_switch(), </div>
<div class="line">|  R4-R12,LR    |           LR is back to __piccolo_os_create_task() after call to __piccolo_pre_switch()</div>
<div class="line">+---------------+</div>
</div><!-- fragment --><p> <code>isr_svcall()</code> restores the kernel state from the main stack and returns to the kernel using the LR. Execution continues in <code><a class="el" href="piccolo__os_8c.html#a2f8a0464da18ff39639b817e46da1deb">__piccolo_pre_switch()</a></code>, which eventually returns to <code><a class="el" href="group___intern.html#ga7441ecb1f631f7840bb96962ca02b38d" title="Create a new task and initialize it&#39;s stack.">piccolo_create_task()</a></code> and then <code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code>.</p>
<h2><a class="anchor" id="autotoc_md69"></a>
piccolo_create_task(&amp;task2_func) and ultimatley piccolo_yield()</h2>
<p >Task 2 and PSP2 are created in exactly the same way as Task 1. Eventually Task 2 calls <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code>, then ultimately the execution returns to <a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a>. After all the tasks have been created then <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a></code> is called.</p>
<h2><a class="anchor" id="autotoc_md70"></a>
piccolo_start()</h2>
<p ><code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a></code> selects the next task and calls <code><a class="el" href="piccolo__os_8c.html#a2f8a0464da18ff39639b817e46da1deb">__piccolo_pre_switch()</a></code> passing the pointer to the PSP. Let's assume Task 1 is next, so it passed in PSP1.</p>
<p >Remember the state of PSP? </p><div class="fragment"><div class="line">Task 1 stack (PSP1)</div>
<div class="line">+---------------+           Saved by isr_svcall() using r0 which is the address of PSP1</div>
<div class="line">|  R4-R12,LR    |           LR will be 0xFFFFFFFD as this is an exception (interrupt).</div>
<div class="line">+---------------+</div>
<div class="line">|  R0-R3,LR,PC  |           Saved by hardware on PSP1</div>
<div class="line">+---------------+</div>
</div><!-- fragment --><p> <code><a class="el" href="piccolo__os_8c.html#a2f8a0464da18ff39639b817e46da1deb">__piccolo_pre_switch()</a></code> saves the kernel state on the main stack: </p><div class="fragment"><div class="line">Main stack (MSP)            </div>
<div class="line">+---------------+           Saved by __piccolo_pre_switch(), </div>
<div class="line">|  R4-R12,LR    |           LR is back to __piccolo_os_create_task() after call to __piccolo_pre_switch()</div>
<div class="line">+---------------+</div>
</div><!-- fragment --><p> It then loads the state (the registers) for task1 from PSP1. It sets the PSP register to R0 and then branches to LR. Since LR is 0xFFFFFFFD then this causes the CPU to end exit handler mode and return to thread mode. </p><div class="fragment"><div class="line">Task 1 stack (PSP1)</div>
<div class="line">+---------------+           Saved by hardware on PSP1</div>
<div class="line">|  R0-R3,LR,PC  |           PC is a pointer to somewhere in the task function, </div>
<div class="line">+---------------+           just after the call to piccolo_yield()</div>
</div><!-- fragment --><p> It now restores R0 to R3 and uses the PC to carry on execution using PSP1. PC is the pointer to somewhere in the task function, just after the call to <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code></p>
<p >PSP1 is now empty or in whatever state it was before Task 1 called <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> </p><div class="fragment"><div class="line">Task 1 stack (PSP1)</div>
<div class="line">+---------------+</div>
<div class="line">+---------------+</div>
</div><!-- fragment --><p> Execution continues until <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> is called again.</p>
<h1><a class="anchor" id="autotoc_md71"></a>
Pre-emptive</h1>
<p >At the moment Piccolo OS is co-operative, in that a task will continue to run until <code><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985" title="Yields the processor to another task.">piccolo_yield()</a></code> is called.</p>
<p >It should be possible to force a context switch using a timer or an interrupt like SysTick which in turn triggers a PendSV. However, my attempts to implement this have so far failed. I have ported the same code to an STM32 BluePill with a Cortex-M3 and pre-emptive tasking works via SysTick/PendSV.</p>
<p >My initial thoughts are that once <code><a class="el" href="piccolo__os__demo_8c.html#ae66f6b31b5ad750f1fe042a706a4e3d4">main()</a></code> is running in handler mode then the Pico C/C++ SDK doesn't process interrupts as expected. The "traditional" approach is to set the interrupt priorities so that the SysTick has a high priority, however my attempts to do that that have so far been without success.</p>
<p >More work is needed.</p>
<h1><a class="anchor" id="autotoc_md72"></a>
Contributing</h1>
<p >I would like to keep this basic version of Piccolo OS intact, as a learning tool. I don't plan on expanding it, even to including pre-emptive multi-tasking (see above).</p>
<p >However, if there is interest then a V2.0 could be started which expands on V1.0 to include pre-emptive multitasking, as well as other things like mutexes, queues, per task memory, etc.</p>
<p >If there is interest then I will start a V2.0 repo and start accepting pull requests.</p>
<p >Having said that, please feel free to fork and continue working on Piccolo OS as you see fit.</p>
<h1><a class="anchor" id="autotoc_md73"></a>
Resources</h1>
<p ><a href="https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-c-sdk.pdf">https://datasheets.raspberrypi.org/pico/raspberry-pi-pico-c-sdk.pdf</a></p>
<p ><a href="https://raspberrypi.github.io/pico-sdk-doxygen/index.html">https://raspberrypi.github.io/pico-sdk-doxygen/index.html</a></p>
<p ><a href="https://interrupt.memfault.com/blog/cortex-m-rtos-context-switching">https://interrupt.memfault.com/blog/cortex-m-rtos-context-switching</a></p>
<p ><a href="https://www.adamh.cz/blog/2016/07/context-switch-on-the-arm-cortex-m0/">https://www.adamh.cz/blog/2016/07/context-switch-on-the-arm-cortex-m0/</a></p>
<p ><a href="https://chromium.googlesource.com/chromiumos/platform/ec/">https://chromium.googlesource.com/chromiumos/platform/ec/</a></p>
<p ><a href="https://github.com/n-k/cortexm-threads">https://github.com/n-k/cortexm-threads</a></p>
<p ><a href="https://github.com/scttnlsn/cmcm">https://github.com/scttnlsn/cmcm</a></p>
<p ><a href="https://github.com/chris-stones/ShovelOS">https://github.com/chris-stones/ShovelOS</a></p>
<p ><a href="https://github.com/jserv/mini-arm-os">https://github.com/jserv/mini-arm-os</a></p>
<p ><a href="https://stackoverflow.com/questions/48537618/cortex-m0-setting-the-priority-of-the-system-exception">https://stackoverflow.com/questions/48537618/cortex-m0-setting-the-priority-of-the-system-exception</a></p>
<p ><a href="https://developer.arm.com/documentation/dui0552/a/the-cortex-m3-processor/exception-model/exception-entry-and-return">https://developer.arm.com/documentation/dui0552/a/the-cortex-m3-processor/exception-model/exception-entry-and-return</a></p>
<p ><a href="https://developer.arm.com/documentation/dui0497/a/the-cortex-m0-processor/programmers-model/core-registers">https://developer.arm.com/documentation/dui0497/a/the-cortex-m0-processor/programmers-model/core-registers</a></p>
<p ><a href="https://github.com/dwelch67/raspberrypi-pico">https://github.com/dwelch67/raspberrypi-pico</a></p>
<p ><a href="https://github.com/davidgiven/FUZIX/tree/rpipico/Kernel/platform-rpipico">https://github.com/davidgiven/FUZIX/tree/rpipico/Kernel/platform-rpipico</a></p>
<p ><a href="https://archive.fosdem.org/2018/schedule/event/multitasking_on_cortexm/attachments/slides/2602/export/events/attachments/multitasking_on_cortexm/slides/2602/Slides.pdf">https://archive.fosdem.org/2018/schedule/event/multitasking_on_cortexm/attachments/slides/2602/export/events/attachments/multitasking_on_cortexm/slides/2602/Slides.pdf</a></p>
<h1><a class="anchor" id="autotoc_md74"></a>
License - 3-Clause BSD License</h1>
<p >Copyright (C) 2021, Gary Sims All rights reserved.</p>
<p >SPDX short identifier: BSD-3-Clause</p>
<h1><a class="anchor" id="autotoc_md75"></a>
Additional Copyrights</h1>
<p >Some portions of code, intentionally or unintentionally, may or may not be attributed to the following people:</p>
<p >Copyright (C) 2017 Scott Nelson: CMCM - <a href="https://github.com/scttnlsn/cmcm">https://github.com/scttnlsn/cmcm</a></p>
<p >Copyright (C) 2015-2018 National Cheng Kung University, Taiwan: mini-arm-os - <a href="https://github.com/jserv/mini-arm-os">https://github.com/jserv/mini-arm-os</a></p>
<p >Copyright (C) 2014-2017 Chris Stones: Shovel OS - <a href="https://github.com/chris-stones/ShovelOS">https://github.com/chris-stones/ShovelOS</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
