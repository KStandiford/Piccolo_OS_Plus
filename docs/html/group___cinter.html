<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Piccolo OS Plus: The Piccolo OS Plus APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Piccolo OS Plus<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">A feature rich extension of Piccolo OS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle"><div class="title">The Piccolo OS Plus APIs</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Here are the Piccolo_Plus APIs, grouped by family function </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">The initializers</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp3e8751415ad9b22f5edc8eabfc2d96d5"></a>These are literally the beginning and the end.</p>
<p ><code><a class="el" href="group___intern.html#gadff28f28fb63a151704985aba1116319" title="Initialize the piccolo run time environment.">piccolo_init()</a></code> is called before any other Piccolo function. <code><a class="el" href="group___intern.html#ga0a198acb7732c0caf302b7cb21edc9f9" title="Start the Piccolo Task scheduler in handler mode.">piccolo_start()</a></code> begins the piccolo scheduler execution, and never returns. </p>
</td></tr>
<tr class="memitem:gadff28f28fb63a151704985aba1116319"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cinter.html#gadff28f28fb63a151704985aba1116319">piccolo_init</a> ()</td></tr>
<tr class="memdesc:gadff28f28fb63a151704985aba1116319"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the piccolo run time environment.  <a href="group___cinter.html#gadff28f28fb63a151704985aba1116319">More...</a><br /></td></tr>
<tr class="separator:gadff28f28fb63a151704985aba1116319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff3adf843eb50836e36f743db1dd8f01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cinter.html#gaff3adf843eb50836e36f743db1dd8f01">piccolo_start</a> ()</td></tr>
<tr class="memdesc:gaff3adf843eb50836e36f743db1dd8f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the Piccolo Task scheduler in handler mode.  <a href="group___cinter.html#gaff3adf843eb50836e36f743db1dd8f01">More...</a><br /></td></tr>
<tr class="separator:gaff3adf843eb50836e36f743db1dd8f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Task creation and execution control</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrp15505b64a403fb111853a59dfe64999e"></a>These are the functions for creating and ending tasks, and controlling their execution. Once a task is running, it can yield the processor to the next task voluntarily. It can also suspend execution (sleep) for a time and allow other tasks to execute.</p>
<p >@Note To send a signal to a task, the sender must have the pointer to the task returned by <code><a class="el" href="group___intern.html#ga7441ecb1f631f7840bb96962ca02b38d" title="Create a new task and initialize it&#39;s stack.">piccolo_create_task()</a></code>. </p>
</td></tr>
<tr class="memitem:ga7441ecb1f631f7840bb96962ca02b38d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cinter.html#ga7441ecb1f631f7840bb96962ca02b38d">piccolo_create_task</a> (void(*pointer_to_task_function)(void))</td></tr>
<tr class="memdesc:ga7441ecb1f631f7840bb96962ca02b38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new task and initialize it's stack.  <a href="group___cinter.html#ga7441ecb1f631f7840bb96962ca02b38d">More...</a><br /></td></tr>
<tr class="separator:ga7441ecb1f631f7840bb96962ca02b38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga449780125dd378c672628587b93dfbcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cinter.html#ga449780125dd378c672628587b93dfbcb">piccolo_end_task</a> ()</td></tr>
<tr class="memdesc:ga449780125dd378c672628587b93dfbcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ends the current task.  <a href="group___cinter.html#ga449780125dd378c672628587b93dfbcb">More...</a><br /></td></tr>
<tr class="separator:ga449780125dd378c672628587b93dfbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8230f73c11759dffd02f266cea58b985"><td class="memItemLeft" align="right" valign="top">static __force_inline void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985">piccolo_yield</a> (void)</td></tr>
<tr class="memdesc:ga8230f73c11759dffd02f266cea58b985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields the processor to another task.  <a href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985">More...</a><br /></td></tr>
<tr class="separator:ga8230f73c11759dffd02f266cea58b985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f7412fd294106bc331d14c335d72b14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cinter.html#ga1f7412fd294106bc331d14c335d72b14">piccolo_syscall</a> (void)</td></tr>
<tr class="memdesc:ga1f7412fd294106bc331d14c335d72b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985">piccolo_yield</a>.  <a href="group___cinter.html#ga1f7412fd294106bc331d14c335d72b14">More...</a><br /></td></tr>
<tr class="separator:ga1f7412fd294106bc331d14c335d72b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1349857a1febc3090dbc9c2773a22bd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cinter.html#ga1349857a1febc3090dbc9c2773a22bd2">piccolo_sleep</a> (uint32_t ticks)</td></tr>
<tr class="memdesc:ga1349857a1febc3090dbc9c2773a22bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">sleeps for a specified number of milliseconds  <a href="group___cinter.html#ga1349857a1febc3090dbc9c2773a22bd2">More...</a><br /></td></tr>
<tr class="separator:ga1349857a1febc3090dbc9c2773a22bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e5d662da97b9d3264cae0b9efb90609"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cinter.html#ga8e5d662da97b9d3264cae0b9efb90609">piccolo_sleep_until</a> (absolute_time_t until)</td></tr>
<tr class="memdesc:ga8e5d662da97b9d3264cae0b9efb90609"><td class="mdescLeft">&#160;</td><td class="mdescRight">sleeps until an absolute time.  <a href="group___cinter.html#ga8e5d662da97b9d3264cae0b9efb90609">More...</a><br /></td></tr>
<tr class="separator:ga8e5d662da97b9d3264cae0b9efb90609"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Task Signals</h2></td></tr>
<tr><td class="ititle" colspan="2"><p ><a class="anchor" id="amgrpc5668c7dfbae177d86547dd713a1a661"></a>Each task has a built in signal channel which can be used for inter-task synchronization. A channel can hold a specified number of signals. (The maximum is a #define value which can be as large as 2^31). Signals are only events which contain no data and do not occupy any memory. Signals can be sent to a task by another task, or by interrupt service handlers or timer or alarm callback routines. (Though only tasks ought to try blocking!) </p>
</td></tr>
<tr class="memitem:gad2c3d360c3a34362795e2692585d415c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cinter.html#gad2c3d360c3a34362795e2692585d415c">piccolo_get_task_id</a> ()</td></tr>
<tr class="memdesc:gad2c3d360c3a34362795e2692585d415c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID (task struct address) of the running task.  <a href="group___cinter.html#gad2c3d360c3a34362795e2692585d415c">More...</a><br /></td></tr>
<tr class="separator:gad2c3d360c3a34362795e2692585d415c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c150669675f7000c331f83d1712f259"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cinter.html#ga2c150669675f7000c331f83d1712f259">piccolo_send_signal</a> (<a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *toTask)</td></tr>
<tr class="memdesc:ga2c150669675f7000c331f83d1712f259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a signal to the specified task.  <a href="group___cinter.html#ga2c150669675f7000c331f83d1712f259">More...</a><br /></td></tr>
<tr class="separator:ga2c150669675f7000c331f83d1712f259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade8fa970b4923f0f37a809ece241140d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cinter.html#gade8fa970b4923f0f37a809ece241140d">piccolo_send_signal_blocking</a> (<a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *toTask)</td></tr>
<tr class="memdesc:gade8fa970b4923f0f37a809ece241140d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a signal to the specified task. If the signal channel is full, block until it is not.  <a href="group___cinter.html#gade8fa970b4923f0f37a809ece241140d">More...</a><br /></td></tr>
<tr class="separator:gade8fa970b4923f0f37a809ece241140d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ba2602cf4ce6101aaa410fdf92aced0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cinter.html#ga1ba2602cf4ce6101aaa410fdf92aced0">piccolo_send_signal_blocking_timeout</a> (<a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *toTask, uint32_t timeout_ms)</td></tr>
<tr class="memdesc:ga1ba2602cf4ce6101aaa410fdf92aced0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a signal to a specified task. Block with a timeout if the channel is full.  <a href="group___cinter.html#ga1ba2602cf4ce6101aaa410fdf92aced0">More...</a><br /></td></tr>
<tr class="separator:ga1ba2602cf4ce6101aaa410fdf92aced0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecae447238e1041d7179460b2fc54e4f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cinter.html#gaecae447238e1041d7179460b2fc54e4f">piccolo_get_signal</a> ()</td></tr>
<tr class="memdesc:gaecae447238e1041d7179460b2fc54e4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to get a signal.  <a href="group___cinter.html#gaecae447238e1041d7179460b2fc54e4f">More...</a><br /></td></tr>
<tr class="separator:gaecae447238e1041d7179460b2fc54e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2044163bd34fbcac7a9669c01bb461d6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cinter.html#ga2044163bd34fbcac7a9669c01bb461d6">piccolo_get_signal_blocking</a> ()</td></tr>
<tr class="memdesc:ga2044163bd34fbcac7a9669c01bb461d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a signal. If none are available, block until one arrives.  <a href="group___cinter.html#ga2044163bd34fbcac7a9669c01bb461d6">More...</a><br /></td></tr>
<tr class="separator:ga2044163bd34fbcac7a9669c01bb461d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fc4dce54e36e19e46458e3f9ef32cbb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cinter.html#ga3fc4dce54e36e19e46458e3f9ef32cbb">piccolo_get_signal_blocking_timeout</a> (uint32_t timeout_ms)</td></tr>
<tr class="memdesc:ga3fc4dce54e36e19e46458e3f9ef32cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to get a signal. Block with a timeout until one arrives if there were none.  <a href="group___cinter.html#ga3fc4dce54e36e19e46458e3f9ef32cbb">More...</a><br /></td></tr>
<tr class="separator:ga3fc4dce54e36e19e46458e3f9ef32cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad92374ebff88fb7e74dd81305ee014b3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cinter.html#gad92374ebff88fb7e74dd81305ee014b3">piccolo_get_signal_all</a> ()</td></tr>
<tr class="memdesc:gad92374ebff88fb7e74dd81305ee014b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the signals available.  <a href="group___cinter.html#gad92374ebff88fb7e74dd81305ee014b3">More...</a><br /></td></tr>
<tr class="separator:gad92374ebff88fb7e74dd81305ee014b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc5a327b7032ac0c6197cf04180b010e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cinter.html#gafc5a327b7032ac0c6197cf04180b010e">piccolo_get_signal_all_blocking</a> ()</td></tr>
<tr class="memdesc:gafc5a327b7032ac0c6197cf04180b010e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the signals available. Block until one arrives if there were none.  <a href="group___cinter.html#gafc5a327b7032ac0c6197cf04180b010e">More...</a><br /></td></tr>
<tr class="separator:gafc5a327b7032ac0c6197cf04180b010e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ab15b8b202cf89ccab7e65ff5dc0045"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___cinter.html#ga9ab15b8b202cf89ccab7e65ff5dc0045">piccolo_get_signal_all_blocking_timeout</a> (uint32_t timeout_ms)</td></tr>
<tr class="memdesc:ga9ab15b8b202cf89ccab7e65ff5dc0045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the signals available. Block with a timeout until one arrives if there were none.  <a href="group___cinter.html#ga9ab15b8b202cf89ccab7e65ff5dc0045">More...</a><br /></td></tr>
<tr class="separator:ga9ab15b8b202cf89ccab7e65ff5dc0045"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7441ecb1f631f7840bb96962ca02b38d" name="ga7441ecb1f631f7840bb96962ca02b38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7441ecb1f631f7840bb96962ca02b38d">&#9670;&nbsp;</a></span>piccolo_create_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> * piccolo_create_task </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>pointer_to_task_function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new task and initialize it's stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer_to_task_function</td><td>The task function to call initially </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Task identifier (Pointer ti task structure) or 0 if create failed</dd></dl>
<p>Allocates a new task and initializes its stack to the start of the given function. Inserts the task at the end of the scheduler task list. Can be called to create a new task while the scheduler is running. (In other words, a running task can create another task at runtime.) </p>

</div>
</div>
<a id="ga449780125dd378c672628587b93dfbcb" name="ga449780125dd378c672628587b93dfbcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga449780125dd378c672628587b93dfbcb">&#9670;&nbsp;</a></span>piccolo_end_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void piccolo_end_task </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ends the current task. </p>
<dl class="section return"><dt>Returns</dt><dd>Never!</dd></dl>
<p>Marks the current task as dead (ZOMBIE) so the scheduler can remove it. (The scheduler must do this, since we cannot free the memory for a task while it running!). The scheduler will immediately remove ZOMBIE tasks from the scheduler chain and add them to the zombies list for the garbage collector to return to free memory.</p>
<dl class="section note"><dt>Note</dt><dd>A task that executes a <code>return</code> will also be ended. </dd></dl>

</div>
</div>
<a id="gaecae447238e1041d7179460b2fc54e4f" name="gaecae447238e1041d7179460b2fc54e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecae447238e1041d7179460b2fc54e4f">&#9670;&nbsp;</a></span>piccolo_get_signal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t piccolo_get_signal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to get a signal. </p>
<dl class="section return"><dt>Returns</dt><dd>1 if signal received, 0 if none were available </dd></dl>

</div>
</div>
<a id="gad92374ebff88fb7e74dd81305ee014b3" name="gad92374ebff88fb7e74dd81305ee014b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad92374ebff88fb7e74dd81305ee014b3">&#9670;&nbsp;</a></span>piccolo_get_signal_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t piccolo_get_signal_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the signals available. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of signals received, 0 if none were available</dd></dl>
<p>Empties the signal channel if signals were available or received in time. </p>

</div>
</div>
<a id="gafc5a327b7032ac0c6197cf04180b010e" name="gafc5a327b7032ac0c6197cf04180b010e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc5a327b7032ac0c6197cf04180b010e">&#9670;&nbsp;</a></span>piccolo_get_signal_all_blocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t piccolo_get_signal_all_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the signals available. Block until one arrives if there were none. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of signals received</dd></dl>
<p>Empties the signal channel. </p>

</div>
</div>
<a id="ga9ab15b8b202cf89ccab7e65ff5dc0045" name="ga9ab15b8b202cf89ccab7e65ff5dc0045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ab15b8b202cf89ccab7e65ff5dc0045">&#9670;&nbsp;</a></span>piccolo_get_signal_all_blocking_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t piccolo_get_signal_all_blocking_timeout </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get all the signals available. Block with a timeout until one arrives if there were none. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_ms</td><td>Time in ms to wait for a signal to arrive</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of signals received, 0 if timeout occurred.</dd></dl>
<p>Empties the signal channel. </p>

</div>
</div>
<a id="ga2044163bd34fbcac7a9669c01bb461d6" name="ga2044163bd34fbcac7a9669c01bb461d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2044163bd34fbcac7a9669c01bb461d6">&#9670;&nbsp;</a></span>piccolo_get_signal_blocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t piccolo_get_signal_blocking </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a signal. If none are available, block until one arrives. </p>
<dl class="section return"><dt>Returns</dt><dd>1 for number of signals received. </dd></dl>

</div>
</div>
<a id="ga3fc4dce54e36e19e46458e3f9ef32cbb" name="ga3fc4dce54e36e19e46458e3f9ef32cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fc4dce54e36e19e46458e3f9ef32cbb">&#9670;&nbsp;</a></span>piccolo_get_signal_blocking_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t piccolo_get_signal_blocking_timeout </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attempt to get a signal. Block with a timeout until one arrives if there were none. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout_ms</td><td>non zero if timeout enabled on blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of signals received. Will be zero is timeout occurred. </dd></dl>

</div>
</div>
<a id="gad2c3d360c3a34362795e2692585d415c" name="gad2c3d360c3a34362795e2692585d415c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2c3d360c3a34362795e2692585d415c">&#9670;&nbsp;</a></span>piccolo_get_task_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> * piccolo_get_task_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ID (task struct address) of the running task. </p>
<dl class="section return"><dt>Returns</dt><dd>piccolo_os_task_t* Task ID of the current task.</dd></dl>
<p>Return the task ID of the running task. Useful for telling callback routines (or other tasks) where to send signals.</p>
<dl class="section note"><dt>Note</dt><dd>Will return the core number before <code>piccolo_start</code> is running on that core. But if you </dd>
<dd>
don't call this except inside a task, you will always get a valid task ID. </dd></dl>

</div>
</div>
<a id="gadff28f28fb63a151704985aba1116319" name="gadff28f28fb63a151704985aba1116319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadff28f28fb63a151704985aba1116319">&#9670;&nbsp;</a></span>piccolo_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void piccolo_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the piccolo run time environment. </p>
<p >Set the scheduler task list to empty and set up the context switching, interrupt handlers, interrupt priorities and interlocks (spinlocks) for the scheduler.</p>
<dl class="section note"><dt>Note</dt><dd>Also called internally on Core 1 when multi-core is enabled. On core1 only the interrupt priorities are set, and all the "one time" stuff is skipped. </dd></dl>

</div>
</div>
<a id="ga2c150669675f7000c331f83d1712f259" name="ga2c150669675f7000c331f83d1712f259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c150669675f7000c331f83d1712f259">&#9670;&nbsp;</a></span>piccolo_send_signal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t piccolo_send_signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *&#160;</td>
          <td class="paramname"><em>toTask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a signal to the specified task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toTask</td><td>pointer to task to send to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if signal sent. &lt;0 if no room</dd></dl>
<p>Send a signal to the designated task. If there is space the signal is sent. If there is no room for the signal, return the error. </p>

</div>
</div>
<a id="gade8fa970b4923f0f37a809ece241140d" name="gade8fa970b4923f0f37a809ece241140d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade8fa970b4923f0f37a809ece241140d">&#9670;&nbsp;</a></span>piccolo_send_signal_blocking()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t piccolo_send_signal_blocking </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *&#160;</td>
          <td class="paramname"><em>toTask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a signal to the specified task. If the signal channel is full, block until it is not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toTask</td><td>pointer to task to send to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 to indicate success.</dd></dl>
<p>Send a signal to the designated task. If there is space the signal is sent. If there is no room for the signal, block until space is available. </p>

</div>
</div>
<a id="ga1ba2602cf4ce6101aaa410fdf92aced0" name="ga1ba2602cf4ce6101aaa410fdf92aced0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ba2602cf4ce6101aaa410fdf92aced0">&#9670;&nbsp;</a></span>piccolo_send_signal_blocking_timeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t piccolo_send_signal_blocking_timeout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *&#160;</td>
          <td class="paramname"><em>toTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Send a signal to a specified task. Block with a timeout if the channel is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toTask</td><td>pointer to task to send to </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>maximum time in ms to wait if the channel is full. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if signal sent. &lt;0 if a timeout occurred while waiting for space in the channel.</dd></dl>
<p>Send a signal to the designated task. If there is space the signal is sent. If there is no room for the signal, wait until the timeout expires or space is available. </p>

</div>
</div>
<a id="ga1349857a1febc3090dbc9c2773a22bd2" name="ga1349857a1febc3090dbc9c2773a22bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1349857a1febc3090dbc9c2773a22bd2">&#9670;&nbsp;</a></span>piccolo_sleep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void piccolo_sleep </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ticks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sleeps for a specified number of milliseconds </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ticks</td><td>number of milliseconds to sleep;</td></tr>
  </table>
  </dd>
</dl>
<p>The scheduler marks the task as blocked and suspends its execution until the delay has expired. </p>

</div>
</div>
<a id="ga8e5d662da97b9d3264cae0b9efb90609" name="ga8e5d662da97b9d3264cae0b9efb90609"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e5d662da97b9d3264cae0b9efb90609">&#9670;&nbsp;</a></span>piccolo_sleep_until()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void piccolo_sleep_until </td>
          <td>(</td>
          <td class="paramtype">absolute_time_t&#160;</td>
          <td class="paramname"><em>until</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sleeps until an absolute time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">until</td><td>absolute time to wake up</td></tr>
  </table>
  </dd>
</dl>
<p>Set the wakeup time for the task and mark it as sleeping for the scheduler. Then suspend execution until the scheduler wakes up the task. </p>

</div>
</div>
<a id="gaff3adf843eb50836e36f743db1dd8f01" name="gaff3adf843eb50836e36f743db1dd8f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff3adf843eb50836e36f743db1dd8f01">&#9670;&nbsp;</a></span>piccolo_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void piccolo_start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the Piccolo Task scheduler in handler mode. </p>
<dl class="section return"><dt>Returns</dt><dd>Never!</dd></dl>
<p>Start the second processor if multi-core mode is enabled. Switch to handler mode and begin the round robin scheduler.</p>
<p >The scheduler starts with the task after the last task run by either core and looks for a task which is not running (on the other core) and not blocked. Along the way it checks if sleeping tasks or tasks blocked for signaling should be unblocked. The first task found ready to run, gets run with the preemption timer reset and armed if preemption is enabled. After the task runs the scheduler checks if it has ended. (Marked as a zombie.) If so, It is removed from the schedulers task list and sent to the garbage collector to free the task's memory.</p>
<p >If no task is ready to run an idle task will be started to sleep for the minimum of the idle slice time or the smallest time remaining of any timeout. Sleep is the Pico sleep routine, so the core goes to sleep for power reduction. If the idle slice time is set to zero, idle will not run.</p>
<dl class="section note"><dt>Note</dt><dd>Runs on <b>both</b> cores if multi-core is enabled </dd></dl>

</div>
</div>
<a id="ga1f7412fd294106bc331d14c335d72b14" name="ga1f7412fd294106bc331d14c335d72b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f7412fd294106bc331d14c335d72b14">&#9670;&nbsp;</a></span>piccolo_syscall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void piccolo_syscall </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="group___cinter.html#ga8230f73c11759dffd02f266cea58b985">piccolo_yield</a>. </p>

</div>
</div>
<a id="ga8230f73c11759dffd02f266cea58b985" name="ga8230f73c11759dffd02f266cea58b985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8230f73c11759dffd02f266cea58b985">&#9670;&nbsp;</a></span>piccolo_yield()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static __force_inline void piccolo_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Yields the processor to another task. </p>
<p >The scheduler will switch to the next ready task in a "round robin" manner. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
