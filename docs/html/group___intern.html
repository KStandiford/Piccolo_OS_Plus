<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Piccolo OS Plus: The Piccolo Plus Internals</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Piccolo OS Plus<span id="projectnumber">&#160;1.01</span>
   </div>
   <div id="projectbrief">A feature rich extension of Piccolo OS</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">The Piccolo Plus Internals</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structpiccolo__os__task__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a></td></tr>
<tr class="memdesc:structpiccolo__os__task__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piccolo OS task data structure.  <a href="group___intern.html#structpiccolo__os__task__t">More...</a><br /></td></tr>
<tr class="separator:structpiccolo__os__task__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:structpiccolo__os__internals__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#structpiccolo__os__internals__t">piccolo_os_internals_t</a></td></tr>
<tr class="memdesc:structpiccolo__os__internals__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Piccolo OS internal data structure.  <a href="group___intern.html#structpiccolo__os__internals__t">More...</a><br /></td></tr>
<tr class="separator:structpiccolo__os__internals__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa6320ec6469eb0b855967802bd711ca3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#gaa6320ec6469eb0b855967802bd711ca3">PICCOLO_OS_STACK_SIZE</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memdesc:gaa6320ec6469eb0b855967802bd711ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a task stack in 32 bit words.  <a href="group___intern.html#gaa6320ec6469eb0b855967802bd711ca3">More...</a><br /></td></tr>
<tr class="separator:gaa6320ec6469eb0b855967802bd711ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga703631a71fd33c17506477df641a7fbf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#ga703631a71fd33c17506477df641a7fbf">PICCOLO_OS_THREAD_PSP</a>&#160;&#160;&#160;0xFFFFFFFD</td></tr>
<tr class="separator:ga703631a71fd33c17506477df641a7fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2c812372e707a1ee62a80cb3927239f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#gaf2c812372e707a1ee62a80cb3927239f">PICCOLO_OS_TIME_SLICE</a>&#160;&#160;&#160;1000</td></tr>
<tr class="memdesc:gaf2c812372e707a1ee62a80cb3927239f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The OS time slice, in microseconds.  <a href="group___intern.html#gaf2c812372e707a1ee62a80cb3927239f">More...</a><br /></td></tr>
<tr class="separator:gaf2c812372e707a1ee62a80cb3927239f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf41b034dc3c049eba615d984a38d2629"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#gaf41b034dc3c049eba615d984a38d2629">PICCOLO_OS_MAX_IDLE</a>&#160;&#160;&#160;700</td></tr>
<tr class="memdesc:gaf41b034dc3c049eba615d984a38d2629"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum time that the scheduler will sleep in the idle task (in usec).  <a href="group___intern.html#gaf41b034dc3c049eba615d984a38d2629">More...</a><br /></td></tr>
<tr class="separator:gaf41b034dc3c049eba615d984a38d2629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2465ada922a63d1f04f8cca8bcde084a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#ga2465ada922a63d1f04f8cca8bcde084a">PICCOLO_OS_NO_IDLE_FOR_SIGNALS</a>&#160;&#160;&#160;true</td></tr>
<tr class="memdesc:ga2465ada922a63d1f04f8cca8bcde084a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, the scheduler will not idle (sleep) if tasks are blocking for signals.  <a href="group___intern.html#ga2465ada922a63d1f04f8cca8bcde084a">More...</a><br /></td></tr>
<tr class="separator:ga2465ada922a63d1f04f8cca8bcde084a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b6aac9d4257c64faae93a58037b113c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#ga4b6aac9d4257c64faae93a58037b113c">PICCOLO_OS_MULTICORE</a>&#160;&#160;&#160;true</td></tr>
<tr class="memdesc:ga4b6aac9d4257c64faae93a58037b113c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable multi-core scheduling.  <a href="group___intern.html#ga4b6aac9d4257c64faae93a58037b113c">More...</a><br /></td></tr>
<tr class="separator:ga4b6aac9d4257c64faae93a58037b113c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86abfef96fa909bde46512610080a545"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#ga86abfef96fa909bde46512610080a545">PICCOLO_OS_MAX_SIGNAL</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:ga86abfef96fa909bde46512610080a545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signal channel size. (max is INT32_MAX)  <a href="group___intern.html#ga86abfef96fa909bde46512610080a545">More...</a><br /></td></tr>
<tr class="separator:ga86abfef96fa909bde46512610080a545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa749ff4348ec86d5c2d224e438dd4bce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#gaa749ff4348ec86d5c2d224e438dd4bce">PICCOLO_SPIN_LOCK_ID</a>&#160;&#160;&#160;PICO_SPINLOCK_ID_OS1</td></tr>
<tr class="separator:gaa749ff4348ec86d5c2d224e438dd4bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga7c6e357870874b0b46cca591cde1b9b7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#ga7c6e357870874b0b46cca591cde1b9b7">piccolo_task_flag_values</a> { <br />
&#160;&#160;<a class="el" href="group___intern.html#gga7c6e357870874b0b46cca591cde1b9b7abce7778ea93669aa227e96d1846570f8">PICCOLO_TASK_RUNNING</a> = 0x1
, <a class="el" href="group___intern.html#gga7c6e357870874b0b46cca591cde1b9b7a865f3ccdce19f6ab52ee18a47cbd433f">PICCOLO_TASK_ZOMBIE</a> = 0x2
, <a class="el" href="group___intern.html#gga7c6e357870874b0b46cca591cde1b9b7a0a11d6297087b2b78df5102e0806b953">PICCOLO_TASK_SLEEPING</a> = 0x4
, <a class="el" href="group___intern.html#gga7c6e357870874b0b46cca591cde1b9b7abe72ab73177b802c0b9c3c5653b9537c">PICCOLO_TASK_GET_SIGNAL_BLOCKED</a> = 0x8
, <br />
&#160;&#160;<a class="el" href="group___intern.html#gga7c6e357870874b0b46cca591cde1b9b7a79ddeacadff405cdc030c0aa89164a94">PICCOLO_TASK_SEND_SIGNAL_BLOCKED</a> = 0x10
, <a class="el" href="group___intern.html#gga7c6e357870874b0b46cca591cde1b9b7a205dbaec30e6f6a970cf480471ad271a">PICCOLO_TASK_BLOCKING</a> = (PICCOLO_TASK_SLEEPING | PICCOLO_TASK_GET_SIGNAL_BLOCKED | PICCOLO_TASK_SEND_SIGNAL_BLOCKED)
<br />
 }</td></tr>
<tr class="separator:ga7c6e357870874b0b46cca591cde1b9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga71a59d00d48e0512b849615509ef1c4b"><td class="memItemLeft" align="right" valign="top">uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#ga71a59d00d48e0512b849615509ef1c4b">__piccolo_os_create_task</a> (uint32_t *task_stack, void(*pointer_to_task_function)(void), uint32_t starting_argument)</td></tr>
<tr class="memdesc:ga71a59d00d48e0512b849615509ef1c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize user task stack for execution.  <a href="group___intern.html#ga71a59d00d48e0512b849615509ef1c4b">More...</a><br /></td></tr>
<tr class="separator:ga71a59d00d48e0512b849615509ef1c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35b9f2fe09b9c47e5748819ab5c91b4d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#ga35b9f2fe09b9c47e5748819ab5c91b4d">__piccolo_send_signal</a> (<a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *task, bool block, uint32_t timeout_ms)</td></tr>
<tr class="memdesc:ga35b9f2fe09b9c47e5748819ab5c91b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for send signal functions.  <a href="group___intern.html#ga35b9f2fe09b9c47e5748819ab5c91b4d">More...</a><br /></td></tr>
<tr class="separator:ga35b9f2fe09b9c47e5748819ab5c91b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d3b5026766f01f3947ee83ee437ffac"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#ga8d3b5026766f01f3947ee83ee437ffac">__piccolo_get_signal</a> (bool block, uint32_t timeout_ms, bool get_all)</td></tr>
<tr class="memdesc:ga8d3b5026766f01f3947ee83ee437ffac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for get signal functions.  <a href="group___intern.html#ga8d3b5026766f01f3947ee83ee437ffac">More...</a><br /></td></tr>
<tr class="separator:ga8d3b5026766f01f3947ee83ee437ffac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabda6a005ffc072854d452ed468b9cd10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#gabda6a005ffc072854d452ed468b9cd10">__piccolo_garbage_man</a> (void)</td></tr>
<tr class="memdesc:gabda6a005ffc072854d452ed468b9cd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task to delete dead tasks.  <a href="group___intern.html#gabda6a005ffc072854d452ed468b9cd10">More...</a><br /></td></tr>
<tr class="separator:gabda6a005ffc072854d452ed468b9cd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5518a5e6b68942455ca2d544f2941209"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#ga5518a5e6b68942455ca2d544f2941209">__piccolo_task_init</a> (void)</td></tr>
<tr class="memdesc:ga5518a5e6b68942455ca2d544f2941209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switch the scheduler to handler mode.  <a href="group___intern.html#ga5518a5e6b68942455ca2d544f2941209">More...</a><br /></td></tr>
<tr class="separator:ga5518a5e6b68942455ca2d544f2941209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf53b6b826e323831509ee5d6c3c340e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#gaf53b6b826e323831509ee5d6c3c340e3">__piccolo_idle</a> (int32_t uSec)</td></tr>
<tr class="memdesc:gaf53b6b826e323831509ee5d6c3c340e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal Idle "task" used by the scheduler to sleep the core.  <a href="group___intern.html#gaf53b6b826e323831509ee5d6c3c340e3">More...</a><br /></td></tr>
<tr class="separator:gaf53b6b826e323831509ee5d6c3c340e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga048859082cafa6f853ea5003ab8bb3fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#ga048859082cafa6f853ea5003ab8bb3fe">__piccolo_start_core1</a> (void)</td></tr>
<tr class="memdesc:ga048859082cafa6f853ea5003ab8bb3fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core 1 code to initialize and immediately start the piccolo scheduler on core 1.  <a href="group___intern.html#ga048859082cafa6f853ea5003ab8bb3fe">More...</a><br /></td></tr>
<tr class="separator:ga048859082cafa6f853ea5003ab8bb3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:gadd49d93bd49fb53059396876e809d706"><td class="memItemLeft" align="right" valign="top">**struct <a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___intern.html#gadd49d93bd49fb53059396876e809d706">piccolo_os_task_t</a></td></tr>
<tr class="separator:gadd49d93bd49fb53059396876e809d706"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structpiccolo__os__task__t" id="structpiccolo__os__task__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structpiccolo__os__task__t">&#9670;&nbsp;</a></span>piccolo_os_task_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct piccolo_os_task_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p >Piccolo OS task data structure. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a642ca2ba60423570a3259b704071ed3a" name="a642ca2ba60423570a3259b704071ed3a"></a>struct <a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *</td>
<td class="fieldname">
next_task</td>
<td class="fielddoc">
<p >next task in scheduler chain </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a59c5b3f27d6c318d55e6c25fd8c15b66" name="a59c5b3f27d6c318d55e6c25fd8c15b66"></a>struct <a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *</td>
<td class="fieldname">
prev_task</td>
<td class="fielddoc">
<p >previous task in scheduler chain </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a67819e76e0f3016008610cca40e4ee18" name="a67819e76e0f3016008610cca40e4ee18"></a>volatile uint32_t</td>
<td class="fieldname">
signal_in</td>
<td class="fielddoc">
<p >input values for the task's input signal channel </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a6ed067fc05f3ac1436df1465ec643bad" name="a6ed067fc05f3ac1436df1465ec643bad"></a>uint32_t</td>
<td class="fieldname">
signal_limit</td>
<td class="fielddoc">
<p >maximum number of signals (+1) the task can queue </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a98d6385834ea8696fa06dc9940816893" name="a98d6385834ea8696fa06dc9940816893"></a>volatile uint32_t</td>
<td class="fieldname">
signal_out</td>
<td class="fielddoc">
<p >output values for the task's input signal channel </p>
</td></tr>
<tr><td class="fieldtype">
<a id="acd77e3d5b1051f68604b0ca477fb19a6" name="acd77e3d5b1051f68604b0ca477fb19a6"></a>uint32_t</td>
<td class="fieldname">
stack[<a class="el" href="group___intern.html#gaa6320ec6469eb0b855967802bd711ca3">PICCOLO_OS_STACK_SIZE</a>]</td>
<td class="fielddoc">
<p >the task stack space </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5ca06e51290585a02c43944a256a0802" name="a5ca06e51290585a02c43944a256a0802"></a>uint32_t *</td>
<td class="fieldname">
stack_ptr</td>
<td class="fielddoc">
<p >the task stack pointer </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a0da33cb21147cfdf17945fb251e202e6" name="a0da33cb21147cfdf17945fb251e202e6"></a>volatile uint32_t</td>
<td class="fieldname">
task_flags</td>
<td class="fielddoc">
<p >Task Status </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a380d1d7ddafe5f5099645f8067d86111" name="a380d1d7ddafe5f5099645f8067d86111"></a>struct <a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *</td>
<td class="fieldname">
task_sending_to</td>
<td class="fielddoc">
<p >task that this one if blocked trying to signal </p>
</td></tr>
<tr><td class="fieldtype">
<a id="af723ad8c6867dc03fd18b44260059f36" name="af723ad8c6867dc03fd18b44260059f36"></a>absolute_time_t</td>
<td class="fieldname">
wakeup</td>
<td class="fielddoc">
<p >end of sleep time or timeout </p>
</td></tr>
</table>

</div>
</div>
<a name="structpiccolo__os__internals__t" id="structpiccolo__os__internals__t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#structpiccolo__os__internals__t">&#9670;&nbsp;</a></span>piccolo_os_internals_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct piccolo_os_internals_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p >Piccolo OS internal data structure. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Data Fields</th></tr>
<tr><td class="fieldtype">
<a id="a6be479cf147169eb9d5cdcdb3780bcb9" name="a6be479cf147169eb9d5cdcdb3780bcb9"></a>volatile <a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *</td>
<td class="fieldname">
current_task</td>
<td class="fielddoc">
<p >last task started on either core for round-robin scheduling </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ab26dcdbc78d073f57ea35684b6b1fbeb" name="ab26dcdbc78d073f57ea35684b6b1fbeb"></a><a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *</td>
<td class="fieldname">
garbage_man</td>
<td class="fielddoc">
<p >Garbage collector task (so schedulers can signal him) </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a5a557db19c7d67683dc860ac615171cb" name="a5a557db19c7d67683dc860ac615171cb"></a>spin_lock_t *</td>
<td class="fieldname">
piccolo_lock</td>
<td class="fielddoc">
<p >spin lock instance </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a09f1643e08ea973a0290fd7f7269b22b" name="a09f1643e08ea973a0290fd7f7269b22b"></a><a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *</td>
<td class="fieldname">
task_list_head</td>
<td class="fielddoc">
<p >pointer to the first task in scheduler list </p>
</td></tr>
<tr><td class="fieldtype">
<a id="ae97c9059c6038edc76cbfc9efe1e595c" name="ae97c9059c6038edc76cbfc9efe1e595c"></a><a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *</td>
<td class="fieldname">
task_list_tail</td>
<td class="fielddoc">
<p >pointer to the last task in scheduler list </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a9cf582b3dc034a4f58e0ce27353acdf1" name="a9cf582b3dc034a4f58e0ce27353acdf1"></a>volatile <a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *</td>
<td class="fieldname">
this_task[2]</td>
<td class="fielddoc">
<p ><code>this_task[i]</code> points to task being run on core <code>i</code>. </p>
</td></tr>
<tr><td class="fieldtype">
<a id="a221eec97cbf21821ab77523d513ed051" name="a221eec97cbf21821ab77523d513ed051"></a><a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *</td>
<td class="fieldname">
zombies</td>
<td class="fielddoc">
<p >(singly linked) list of dead tasks for garbage collection </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gaf41b034dc3c049eba615d984a38d2629" name="gaf41b034dc3c049eba615d984a38d2629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf41b034dc3c049eba615d984a38d2629">&#9670;&nbsp;</a></span>PICCOLO_OS_MAX_IDLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PICCOLO_OS_MAX_IDLE&#160;&#160;&#160;700</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum time that the scheduler will sleep in the idle task (in usec). </p>
<p >This will influence the latency for tasks waking up for signals, for example. Setting this to zero will disable the idle task. </p>

</div>
</div>
<a id="ga86abfef96fa909bde46512610080a545" name="ga86abfef96fa909bde46512610080a545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86abfef96fa909bde46512610080a545">&#9670;&nbsp;</a></span>PICCOLO_OS_MAX_SIGNAL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PICCOLO_OS_MAX_SIGNAL&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signal channel size. (max is INT32_MAX) </p>
<p >The number of signals which can be queued in a signal channel (+1). It can be set smaller for testing or special purposes. </p><dl class="section remark"><dt>Remarks</dt><dd>Remember that signals do not use any memory, so there is no penalty for a large number here. </dd></dl>

</div>
</div>
<a id="ga4b6aac9d4257c64faae93a58037b113c" name="ga4b6aac9d4257c64faae93a58037b113c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b6aac9d4257c64faae93a58037b113c">&#9670;&nbsp;</a></span>PICCOLO_OS_MULTICORE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PICCOLO_OS_MULTICORE&#160;&#160;&#160;true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable multi-core scheduling. </p>

</div>
</div>
<a id="ga2465ada922a63d1f04f8cca8bcde084a" name="ga2465ada922a63d1f04f8cca8bcde084a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2465ada922a63d1f04f8cca8bcde084a">&#9670;&nbsp;</a></span>PICCOLO_OS_NO_IDLE_FOR_SIGNALS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PICCOLO_OS_NO_IDLE_FOR_SIGNALS&#160;&#160;&#160;true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If true, the scheduler will not idle (sleep) if tasks are blocking for signals. </p>
<p >If set to false, the scheduler will run the idle task for the minimum of PICCOLO_OS_MAX_IDLE or the smallest time remaining for any task with a timeout running. This will improve power consumption but potentially delay the response of any task waiting for a signal. This may make good sense for applications without serious response time concerns. </p>

</div>
</div>
<a id="gaa6320ec6469eb0b855967802bd711ca3" name="gaa6320ec6469eb0b855967802bd711ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa6320ec6469eb0b855967802bd711ca3">&#9670;&nbsp;</a></span>PICCOLO_OS_STACK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PICCOLO_OS_STACK_SIZE&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of a task stack in 32 bit words. </p>
<dl class="section note"><dt>Note</dt><dd>Must be <b>even</b>, for exception frame stack alignment! </dd></dl>

</div>
</div>
<a id="ga703631a71fd33c17506477df641a7fbf" name="ga703631a71fd33c17506477df641a7fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga703631a71fd33c17506477df641a7fbf">&#9670;&nbsp;</a></span>PICCOLO_OS_THREAD_PSP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PICCOLO_OS_THREAD_PSP&#160;&#160;&#160;0xFFFFFFFD</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Exception return behavior value </p>

</div>
</div>
<a id="gaf2c812372e707a1ee62a80cb3927239f" name="gaf2c812372e707a1ee62a80cb3927239f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2c812372e707a1ee62a80cb3927239f">&#9670;&nbsp;</a></span>PICCOLO_OS_TIME_SLICE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PICCOLO_OS_TIME_SLICE&#160;&#160;&#160;1000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The OS time slice, in microseconds. </p>
<p >Setting time slice to zero will disable preemptive scheduling! </p>

</div>
</div>
<a id="gaa749ff4348ec86d5c2d224e438dd4bce" name="gaa749ff4348ec86d5c2d224e438dd4bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa749ff4348ec86d5c2d224e438dd4bce">&#9670;&nbsp;</a></span>PICCOLO_SPIN_LOCK_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PICCOLO_SPIN_LOCK_ID&#160;&#160;&#160;PICO_SPINLOCK_ID_OS1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Piccolo spin lock to use </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga7c6e357870874b0b46cca591cde1b9b7" name="ga7c6e357870874b0b46cca591cde1b9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c6e357870874b0b46cca591cde1b9b7">&#9670;&nbsp;</a></span>piccolo_task_flag_values</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___intern.html#ga7c6e357870874b0b46cca591cde1b9b7">piccolo_task_flag_values</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7c6e357870874b0b46cca591cde1b9b7abce7778ea93669aa227e96d1846570f8" name="gga7c6e357870874b0b46cca591cde1b9b7abce7778ea93669aa227e96d1846570f8"></a>PICCOLO_TASK_RUNNING&#160;</td><td class="fielddoc"><p >Task is running. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7c6e357870874b0b46cca591cde1b9b7a865f3ccdce19f6ab52ee18a47cbd433f" name="gga7c6e357870874b0b46cca591cde1b9b7a865f3ccdce19f6ab52ee18a47cbd433f"></a>PICCOLO_TASK_ZOMBIE&#160;</td><td class="fielddoc"><p >Task has ended and should be removed by the scheduler. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7c6e357870874b0b46cca591cde1b9b7a0a11d6297087b2b78df5102e0806b953" name="gga7c6e357870874b0b46cca591cde1b9b7a0a11d6297087b2b78df5102e0806b953"></a>PICCOLO_TASK_SLEEPING&#160;</td><td class="fielddoc"><p >Task has a timeout running. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7c6e357870874b0b46cca591cde1b9b7abe72ab73177b802c0b9c3c5653b9537c" name="gga7c6e357870874b0b46cca591cde1b9b7abe72ab73177b802c0b9c3c5653b9537c"></a>PICCOLO_TASK_GET_SIGNAL_BLOCKED&#160;</td><td class="fielddoc"><p >Task blocked getting signal. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7c6e357870874b0b46cca591cde1b9b7a79ddeacadff405cdc030c0aa89164a94" name="gga7c6e357870874b0b46cca591cde1b9b7a79ddeacadff405cdc030c0aa89164a94"></a>PICCOLO_TASK_SEND_SIGNAL_BLOCKED&#160;</td><td class="fielddoc"><p >Task block sending signal. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7c6e357870874b0b46cca591cde1b9b7a205dbaec30e6f6a970cf480471ad271a" name="gga7c6e357870874b0b46cca591cde1b9b7a205dbaec30e6f6a970cf480471ad271a"></a>PICCOLO_TASK_BLOCKING&#160;</td><td class="fielddoc"><p >Mask to detect task blocked for some reason. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabda6a005ffc072854d452ed468b9cd10" name="gabda6a005ffc072854d452ed468b9cd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabda6a005ffc072854d452ed468b9cd10">&#9670;&nbsp;</a></span>__piccolo_garbage_man()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __piccolo_garbage_man </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task to delete dead tasks. </p>
<p >The task is created during the scheduler start-up on core 0. When it runs, it tries to free the space for all the dead tasks on the zombies list. (The scheduler cannot call <code>free()</code>, because it is an interrupt handler and would break the mutex that protects <code>free()</code> and <code>malloc()</code>). </p>

</div>
</div>
<a id="ga8d3b5026766f01f3947ee83ee437ffac" name="ga8d3b5026766f01f3947ee83ee437ffac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d3b5026766f01f3947ee83ee437ffac">&#9670;&nbsp;</a></span>__piccolo_get_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t __piccolo_get_signal </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>get_all</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper for get signal functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>true if blocking on send </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>non zero if timeout enabled on blocking </td></tr>
    <tr><td class="paramname">get_all</td><td>if true, get ALL signals available. Otherwise just get one. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of signals received. Can be zero on timeout or non-blocking</dd></dl>
<p>Get a signal for the current task. Return the number received. If there are no signals available, return zero unless blocking was requested. If blocking is necessary, start a timeout as well if one was requested.</p>
<dl class="section note"><dt>Note</dt><dd>With only ONE receiver, we do not have to lock anything. </dd></dl>

</div>
</div>
<a id="gaf53b6b826e323831509ee5d6c3c340e3" name="gaf53b6b826e323831509ee5d6c3c340e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf53b6b826e323831509ee5d6c3c340e3">&#9670;&nbsp;</a></span>__piccolo_idle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __piccolo_idle </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>uSec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal Idle "task" used by the scheduler to sleep the core. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uSec</td><td>the number of microseconds to sleep</td></tr>
  </table>
  </dd>
</dl>
<p>Enter sleep mode and then "yield" back to the scheduler. Entry and parameter passing is set up in a dummy stack frame before switching context.</p>
<dl class="section note"><dt>Note</dt><dd>Can be running on <b>both</b> cores with different sleep times </dd></dl>

</div>
</div>
<a id="ga71a59d00d48e0512b849615509ef1c4b" name="ga71a59d00d48e0512b849615509ef1c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71a59d00d48e0512b849615509ef1c4b">&#9670;&nbsp;</a></span>__piccolo_os_create_task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t * __piccolo_os_create_task </td>
          <td>(</td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>task_stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>pointer_to_task_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>starting_argument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize user task stack for execution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task_stack</td><td>pointer to the END of the task stack (array). </td></tr>
    <tr><td class="paramname">pointer_to_task_function</td><td>the function to execute. </td></tr>
    <tr><td class="paramname">starting_argument</td><td>unsigned integer argument for function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>"Current" stack pointer for the task.</dd></dl>
<p>We setup the initial stack frame with:</p><ul>
<li>"software saved" LR set to PICCOLO_OS_THREAD_PSP so that exception return works correctly.</li>
<li>PC Set to the task starting point (function entry)</li>
<li>Exception frame LR set to <code><a class="el" href="group___cinter.html#ga449780125dd378c672628587b93dfbcb" title="Ends the current task, never returns.">piccolo_end_task()</a></code> in case the task exits or returns</li>
</ul>
<p >PICCOLO_OS_THREAD_PSP means:</p><ul>
<li>Return to Thread mode.</li>
<li>Exception return gets state from the process stack.</li>
<li>Execution uses PSP after return. See also: <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0552a/Babefdjc.html">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0552a/Babefdjc.html</a></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The starting argument is placed in R0, but this is only used internally for the totally fake idle task. </dd></dl>

</div>
</div>
<a id="ga35b9f2fe09b9c47e5748819ab5c91b4d" name="ga35b9f2fe09b9c47e5748819ab5c91b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35b9f2fe09b9c47e5748819ab5c91b4d">&#9670;&nbsp;</a></span>__piccolo_send_signal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t __piccolo_send_signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> *&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper for send signal functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>pointer to task to send to </td></tr>
    <tr><td class="paramname">block</td><td>true if blocking on send </td></tr>
    <tr><td class="paramname">timeout_ms</td><td>non zero if timeout enabled on blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if signal sent. &lt;0 if no room, or timeout occurred on blocking</dd></dl>
<p>Send a signal to the designated task. If there is space the signal is sent. If there is no room for the signal, return the error unless blocking was requested. If blocking is necessary, start a timeout as well, if one was requested.</p>
<dl class="section note"><dt>Note</dt><dd>Since multiple senders are allowed, we must use the spinlock. </dd></dl>

</div>
</div>
<a id="ga048859082cafa6f853ea5003ab8bb3fe" name="ga048859082cafa6f853ea5003ab8bb3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga048859082cafa6f853ea5003ab8bb3fe">&#9670;&nbsp;</a></span>__piccolo_start_core1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __piccolo_start_core1 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Core 1 code to initialize and immediately start the piccolo scheduler on core 1. </p>
<p >Remember that the <code><a class="el" href="group___cinter.html#gadff28f28fb63a151704985aba1116319" title="Initialize the piccolo run time environment.">piccolo_init()</a></code> checks the core number and does not setup the data structures or the interrupt vector table if it is not core 0. <code><a class="el" href="group___cinter.html#gaff3adf843eb50836e36f743db1dd8f01" title="Start the Piccolo Task scheduler.">piccolo_start()</a></code> takes similar precautions. The scheduler will run on both cores at once. </p>

</div>
</div>
<a id="ga5518a5e6b68942455ca2d544f2941209" name="ga5518a5e6b68942455ca2d544f2941209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5518a5e6b68942455ca2d544f2941209">&#9670;&nbsp;</a></span>__piccolo_task_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __piccolo_task_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switch the scheduler to handler mode. </p>
<p >After a reset, the processor is in thread mode. Switch to handler mode, so that the Piccolo OS kernel runs in handler mode, and to ensure the correct return from an exception/interrupt later when switching to a task. We make a dummy stack and arrange to route the service call exception back to ourselves! </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gadd49d93bd49fb53059396876e809d706" name="gadd49d93bd49fb53059396876e809d706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd49d93bd49fb53059396876e809d706">&#9670;&nbsp;</a></span>piccolo_os_task_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">** struct <a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a> <a class="el" href="group___intern.html#structpiccolo__os__task__t">piccolo_os_task_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
